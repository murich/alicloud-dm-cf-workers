diff --git a/node_modules/@darabonba/typescript/dist/core.js b/node_modules/@darabonba/typescript/dist/core.js
index 76c1616..eb6d514 100644
--- a/node_modules/@darabonba/typescript/dist/core.js
+++ b/node_modules/@darabonba/typescript/dist/core.js
@@ -143,6 +143,91 @@ var Response = /** @class */ (function () {
     return Response;
 }());
 exports.Response = Response;
+// FetchResponse: Adapter for Cloudflare Workers fetch API
+var FetchResponse = /** @class */ (function () {
+    function FetchResponse(fetchResponse) {
+        this.statusCode = fetchResponse.status;
+        this.statusMessage = fetchResponse.statusText;
+        this.headers = this.convertHeaders(fetchResponse.headers);
+        this._fetchResponse = fetchResponse;
+        // Create a mock readable stream with the fetch response
+        this.body = this.createMockReadable();
+    }
+    FetchResponse.prototype.convertHeaders = function (headers) {
+        var results = {};
+        headers.forEach(function (value, key) {
+            results[key] = value;
+        });
+        return results;
+    };
+    FetchResponse.prototype.createMockReadable = function () {
+        var _this = this;
+        var listeners = {};
+        var _bodyPromise = null;
+        var getBodyBuffer = function () {
+            if (!_bodyPromise) {
+                _bodyPromise = _this._fetchResponse.arrayBuffer().then(function (ab) { return Buffer.from(ab); });
+            }
+            return _bodyPromise;
+        };
+        return {
+            on: function (event, handler) {
+                if (!listeners[event]) {
+                    listeners[event] = [];
+                }
+                listeners[event].push(handler);
+                if (event === 'data' || event === 'end') {
+                    // Trigger handlers async
+                    setImmediate(function () {
+                        getBodyBuffer().then(function (buffer) {
+                            if (event === 'data' && listeners['data']) {
+                                listeners['data'].forEach(function (h) { return h(buffer); });
+                            }
+                            if (event === 'end' && listeners['end']) {
+                                listeners['end'].forEach(function (h) { return h(); });
+                            }
+                        }).catch(function (err) {
+                            if (listeners['error']) {
+                                listeners['error'].forEach(function (h) { return h(err); });
+                            }
+                        });
+                    });
+                }
+                return this;
+            },
+            once: function (event, handler) {
+                var self = this;
+                var onceHandler = function () {
+                    handler.apply(void 0, arguments);
+                    self.removeListener(event, onceHandler);
+                };
+                return this.on(event, onceHandler);
+            },
+            removeListener: function (event, handler) {
+                if (listeners[event]) {
+                    listeners[event] = listeners[event].filter(function (h) { return h !== handler; });
+                }
+                return this;
+            },
+            pipe: function () { return this; },
+            destroy: function () { listeners = {}; }
+        };
+    };
+    FetchResponse.prototype.readBytes = function () {
+        return __awaiter(this, void 0, void 0, function () {
+            var arrayBuffer;
+            return __generator(this, function (_a) {
+                switch (_a.label) {
+                    case 0: return [4 /*yield*/, this._fetchResponse.arrayBuffer()];
+                    case 1:
+                        arrayBuffer = _a.sent();
+                        return [2 /*return*/, Buffer.from(arrayBuffer)];
+                }
+            });
+        });
+    };
+    return FetchResponse;
+}());
 function buildURL(request) {
     var url = "".concat(request.protocol, "://").concat(request.headers['host']);
     if (request.port) {
@@ -169,58 +254,48 @@ function isModelClass(t) {
 function doAction(request, runtime) {
     if (runtime === void 0) { runtime = null; }
     return __awaiter(this, void 0, void 0, function () {
-        var url, method, options, agentOptions, response;
+        var url, method, fetchOptions, timeout, controller, timeoutId, response, e_1;
         return __generator(this, function (_a) {
             switch (_a.label) {
                 case 0:
                     url = buildURL(request);
                     method = (request.method || 'GET').toUpperCase();
-                    options = {
+                    fetchOptions = {
                         method: method,
                         headers: request.headers
                     };
-                    if (method !== 'GET' && method !== 'HEAD') {
-                        options.data = request.body;
+                    if (method !== 'GET' && method !== 'HEAD' && request.body) {
+                        fetchOptions.body = request.body;
                     }
+                    timeout = 30000;
                     if (runtime) {
                         if (typeof runtime.timeout !== 'undefined') {
-                            options.timeout = Number(runtime.timeout);
-                        }
-                        if (typeof runtime.readTimeout !== 'undefined') {
-                            options.readTimeout = Number(runtime.readTimeout);
+                            timeout = Number(runtime.timeout);
                         }
-                        if (typeof runtime.connectTimeout !== 'undefined') {
-                            options.connectTimeout = Number(runtime.connectTimeout);
-                        }
-                        if (typeof runtime.ignoreSSL !== 'undefined') {
-                            options.rejectUnauthorized = !runtime.ignoreSSL;
-                        }
-                        if (typeof runtime.key !== 'undefined') {
-                            options.key = String(runtime.key);
-                        }
-                        if (typeof runtime.cert !== 'undefined') {
-                            options.cert = String(runtime.cert);
-                        }
-                        if (typeof runtime.ca !== 'undefined') {
-                            options.ca = String(runtime.ca);
-                        }
-                        agentOptions = {
-                            keepAlive: true,
-                        };
-                        if (typeof runtime.keepAlive !== 'undefined') {
-                            agentOptions.keepAlive = runtime.keepAlive;
-                            if (request.protocol && request.protocol.toLowerCase() === 'https') {
-                                options.agent = new https_1.Agent(agentOptions);
-                            }
-                            else {
-                                options.agent = new http_1.Agent(agentOptions);
-                            }
+                        else if (typeof runtime.readTimeout !== 'undefined') {
+                            timeout = Number(runtime.readTimeout);
                         }
                     }
-                    return [4 /*yield*/, httpx.request(url, options)];
+                    controller = new AbortController();
+                    timeoutId = setTimeout(function () { return controller.abort(); }, timeout);
+                    fetchOptions.signal = controller.signal;
+                    _a.label = 1;
                 case 1:
+                    _a.trys.push([1, 3, 4, 5]);
+                    return [4 /*yield*/, fetch(url, fetchOptions)];
+                case 2:
                     response = _a.sent();
-                    return [2 /*return*/, new Response(response)];
+                    return [2 /*return*/, new FetchResponse(response)];
+                case 3:
+                    e_1 = _a.sent();
+                    if (e_1.name === 'AbortError') {
+                        throw new Error("Request timeout after ".concat(timeout, "ms"));
+                    }
+                    throw e_1;
+                case 4:
+                    clearTimeout(timeoutId);
+                    return [7 /*endfinally*/];
+                case 5: return [2 /*return*/];
             }
         });
     });
